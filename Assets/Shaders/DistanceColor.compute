#pragma kernel CSMain

// First mesh data (the one shader is attached to)
StructuredBuffer<float3> MeshVertices;
uint MeshVertexCount;

// Second mesh data (the reference mesh)
StructuredBuffer<float3> ReferenceMeshVertices;
uint ReferenceMeshVertexCount;

// Transform matrices
float4x4 LocalToWorld; // Transform for current mesh
float4x4 ReferenceLocalToWorld; // Transform for reference mesh

// Coloring parameters
float MaxDistance;
float3 CloseColor;
float3 FarColor;

// Output
RWTexture2D<float4> Result;

float CalculateMinDistance(float3 vertex)
{
    float minDist = 1e10; // Very large initial value

    // Transform current vertex to world space
    float3 worldVertex = mul(LocalToWorld, float4(vertex, 1.0)).xyz;

    // Find minimum distance to any vertex in reference mesh
    for (uint i = 0; i < ReferenceMeshVertexCount; i++)
    {
        float3 refWorldPos = mul(ReferenceLocalToWorld, float4(ReferenceMeshVertices[i], 1.0)).xyz;
        float dist = distance(worldVertex, refWorldPos);
        minDist = min(minDist, dist);
    }

    return minDist;
}

[numthreads(8,8,1)]
void CSMain(uint3 id : SV_DispatchThreadID)
{
    uint width, height;
    Result.GetDimensions(width, height);

    // Map texture pixels to mesh vertices (simplified mapping)
    float normalizedX = (float)id.x / width;
    float normalizedY = (float)id.y / height;

    uint vertexIndex = min((uint)(normalizedX * normalizedY * MeshVertexCount), MeshVertexCount - 1);

    float dist = CalculateMinDistance(MeshVertices[vertexIndex]);

    // Normalize distance and clamp
    float normalizedDistance = saturate(dist / MaxDistance);

    // Interpolate between colors
    float3 color = lerp(CloseColor, FarColor, normalizedDistance);

    // Output the result
    Result[id.xy] = float4(color, 1.0);
}
